filetype off
runtime macros/matchit.vim

if has('nvim')
  let g:plugin_path = '~/nvim/plugged'
else
  let g:plugin_path = '~/.vim/plugged'
endif

call plug#begin(g:plugin_path)

" Vim layout + window related fun
Plug 'justinmk/vim-dirvish'                                 " Dirvish > netrw
Plug 'mbbill/undotree', { 'on': 'UndotreeToggle' }          " View undo history as tree
Plug 'mhinz/vim-sayonara'                                   " Sanely quit buffers/windows etc.
Plug 'kopischke/vim-fetch'                                  " GNU line/column format!

" Searching related
Plug 'mhinz/vim-grepper'                                    " Async grepprg
Plug 'romainl/vim-qf'                                       " Tame quickfix
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' } | Plug 'junegunn/fzf.vim'
Plug 'junegunn/vim-slash'

" External integrations
Plug 'w0rp/ale'
Plug 'airblade/vim-gitgutter'                               " Git symbols in gutter
Plug 'tpope/vim-fugitive' | Plug 'tpope/vim-rhubarb' | Plug 'junegunn/gv.vim' " Git command wrappers
Plug 'tpope/vim-eunuch'                                     " Wrappers for UNIX

" Typing/Autocomplete support
Plug 'ajh17/VimCompletesMe'
Plug 'tpope/vim-endwise'                                    " Insert 'end' in ruby as smartly as braces

" Movement/Text-alteration
Plug 'justinmk/vim-sneak'                                   " 2 character jump motion
Plug 'tpope/vim-surround'                                   " Easily deal with surrounding quotes
Plug 'tpope/vim-commentary'                                 " Comment/uncomment textobjs
Plug 'tpope/vim-unimpaired'                                 " Collection of paired commands
Plug 'tpope/vim-repeat'                                     " repeat surround/comment/unimpaired actions
Plug 'tommcdo/vim-lion'                                     " Alignment motion
Plug 'AndrewRadev/splitjoin.vim'                            " SplitJoin
Plug 'kana/vim-niceblock'                                   " No more barrier between visual/visual block

" New text objs
Plug 'wellle/targets.vim'
Plug 'coderifous/textobj-word-column.vim'

" Replace-from-register operator (eg. "0riw == replace inner word with content
" from register 0)
Plug 'kana/vim-operator-user' | Plug 'kana/vim-operator-replace'

" Colors
Plug 'lifepillar/vim-solarized8'
Plug 'itchyny/lightline.vim'

" Web
Plug 'kchmck/vim-coffee-script'
Plug 'othree/html5.vim'
Plug 'cakebaker/scss-syntax.vim'
Plug 'vim-ruby/vim-ruby'

" Ocaml + Elm
Plug 'rgrinberg/vim-ocaml'
Plug 'let-def/ocp-indent-vim'
Plug 'ElmCast/elm-vim'
Plug '~/.opam/system/share/merlin', { 'for': ['ocaml', 'merlin' ], 'rtp': 'vim' }

" Other stuff
Plug 'rust-lang/rust.vim', { 'for': 'rust' }
Plug 'racer-rust/vim-racer', { 'for': 'rust' }
Plug 'cespare/vim-toml'
Plug 'tmux-plugins/vim-tmux'
Plug 'pangloss/vim-javascript', { 'for': 'javascript' }

call plug#end()

filetype plugin indent on

if filereadable(glob("~/dotfiles/vimfiles/helpers.vim"))
  source ~/dotfiles/vimfiles/helpers.vim
endif

" Vim Settings
let mapleader="\<Space>" " Space for leader is so satisfying
syntax on

" Make vim friendlier for pairing if needed
let g:pair_programming = 0
call Load(Vimfiles("pairing.vim"))


" Command behaviour
set noshowcmd
set noshowmode
set ruler
set laststatus=2

" Text-y stuff
set shiftround " 'h' and 'l' will wrap around lines
set whichwrap+=<,>,h,l

" Line/line number
set number

if has('gui')
  set relativenumber
  set cursorline
else
  set norelativenumber
  set nocursorline
end

" Tabs
set expandtab
set smarttab
set tabstop=2
set shiftwidth=2

" File-system
set autoread
set noswapfile
set nowritebackup
set nrformats-=octal

" Search
set nohlsearch
set incsearch
set ignorecase
set smartcase

" Terminal errors
set noerrorbells
set visualbell

" Key timeouts
set tm=500
set ttimeoutlen=50

" Split opening positions
set splitright
set splitbelow

" Screen scrolling behaviour
set scrolloff=10 " keep cursor relatively centered
set sidescrolloff=10

" Tagfile
set tags=./.tags;

" Showing invisible characters
set listchars=tab:»\ ,extends:›,trail:⋅ " textmate
set fillchars=stlnc:\-,vert:\|
set showbreak=›››

" Command tab-completion
set wildmenu
set wildmode=list:full,full
set wildignore=*.o,*.obj,*~,*.pyc,*.so,*.swp,tmp/
set wildignore+=*.pdf,*.jpg,*.dmg,*.zip,*.png,*.gif,*DS_Store*

set virtualedit=block

set complete+=kspell
set completeopt=menu,menuone " Don't show scratch window

set hidden
set switchbuf=useopen

set updatetime=750
set lazyredraw

set guifont=PragmataPro:h15
set guioptions-=r
set guioptions-=e
set guioptions-=L

if has("persistent_undo")
  let undoDir = expand('$HOME/.undodir')
  call system('mkdir -p ' . undoDir)
  let &undodir = undoDir
  set undofile
endif

" PLUGINS

" vim-ruby highlight operators
let ruby_operators    = 1
let ruby_no_expensive = 1

" Ack.vim style quickfix mappings
let g:qf_mapping_ack_style  = 1
let g:qf_auto_open_quickfix = 0
let g:qf_auto_open_loclist  = 0

" Don't update as I type
let g:gitgutter_realtime           = 0
let g:gitgutter_eager              = 1
set signcolumn=yes

" Elm
let g:elm_jump_to_error = 0
let g:elm_make_show_warnings = 1
let g:elm_syntastic_show_warnings = 0
let g:elm_browser_command = ""
let g:elm_detailed_complete = 0
let g:elm_format_autosave = 0
let g:elm_format_fail_silently = 0
let g:elm_setup_keybindings = 0

" ALE
let g:ale_elm_make_executable = 'elm-make'
let g:ale_elm_make_use_global = 1

let g:ale_set_loclist = 0
let g:ale_set_quickfix = 1

let g:ale_lint_on_text_changed = 'never'
let g:ale_lint_on_enter = 0
let g:ale_lint_on_filetype_changed  = 0

if executable('rg')
  let g:gitgutter_grep_command = 'rg --color never'
elseif executable('ag')
  let g:gitgutter_grep_command = 'ag --nocolor'
endif

" Undotree
let g:undotree_WindowLayout       = 4
let g:undotree_SplitWidth         = 35
let g:undotree_SetFocusWhenToggle = 1

function! g:Undotree_CustomMap()
  nmap <buffer> K <plug>UndotreeGoNextState
  nmap <buffer> J <plug>UndotreeGoPreviousState
  nmap <buffer> q <plug>UndotreeClose
endfunction

" Racer
let g:racer_cmd    = "racer"
let $RUST_SRC_PATH = glob("~/rust/src/")
let $CARGO_HOME    = glob("~/cargo")

" Grepper
let g:grepper = {
  \ 'quickfix': 1,
  \ 'open': 1,
  \ 'switch': 1,
  \ 'jump': 0,
  \ 'tools': ['rg', 'ag'],
  \ }

" vim-sneak
let g:sneak#s_next = 1

" targets.vim
let g:targets_aiAI = 'ai  ' " Disable A and I because it's used by niceblock

let g:fzf_command_prefix = 'Fzf'

" MAPPINGS

" god who uses this
nnoremap Q <NOP>

" Fingers are already there...
nnoremap <C-j> <C-d>
nnoremap <C-k> <C-u>
vnoremap <C-j> <C-d>
vnoremap <C-k> <C-u>

" Readline-style key bindings in command-line (excerpt from rsi.vim)
cnoremap        <C-A> <Home>
cnoremap        <C-B> <Left>
cnoremap <expr> <C-D> getcmdpos()>strlen(getcmdline())?"\<Lt>C-D>":"\<Lt>Del>"
cnoremap <expr> <C-F> getcmdpos()>strlen(getcmdline())?&cedit:"\<Lt>Right>"
cnoremap        <M-b> <S-Left>
cnoremap        <M-f> <S-Right>
silent! exe "set <S-Left>=\<Esc>b"
silent! exe "set <S-Right>=\<Esc>f"

" Trim trailing whitespace
nnoremap <Leader>tw :call TrimWhitespace()<CR>

if executable('rg') && executable('ag')
  " Integrate with ripgrep
  set grepprg=rg\ --vimgrep
  set grepformat=%f:%l:%c:%m,%f:%l:%m
  nnoremap <Leader>/ :FzfAg<CR>

  if PluginLoaded('vim-grepper')
    nmap gs  <plug>(GrepperOperator)
    xmap gs  <plug>(GrepperOperator)

    nnoremap <Leader>s :Grepper -noswitch -tool rg -cword -noprompt<CR>
    nnoremap <Leader>ag :Grepper -tool ag -query ''<Left>
    nnoremap <Leader>rg :Grepper -tool rg -query ''<Left>
  endif
endif

" SplitJoin Bindings
nnoremap <silent> J :<C-u>call TryWithDefault('SplitjoinJoin', 'J')<CR>
nnoremap <silent> S :<C-u>call TryWithDefault('SplitjoinSplit', "r\015")<CR>

if PluginLoaded('vim-operator-user') && PluginLoaded('vim-operator-replace')
  map r <Plug>(operator-replace)
endif

" Undo mappings
if PluginInstalled('undotree')
  nnoremap <Leader>u :UndotreeToggle<CR>
endif

" Use Sayonara for quitting
if PluginLoaded('vim-sayonara')
  nnoremap <Leader>x :Sayonara<CR>y<CR>
  nnoremap <Leader>q :w<CR>:Sayonara<CR>
else
  nnoremap <Leader>x :q!<CR>
  nnoremap <Leader>q :wq<CR>
endif

nnoremap <Leader>w :w<CR>
nnoremap <Leader>Q :q!<CR>

" Easily make changes to vimrc
if PluginLoaded('vim-plug')
  nnoremap <Leader>U :PlugInstall<CR>:PlugUpdate<CR>:PlugClean<CR>
  nnoremap <Leader>S :call GenerateSnapshot()<CR>
endif

" no need for this to be mac only; can compile from source
if PluginLoaded('fzf.vim')
  nnoremap <Leader>fa :FzfFiles<CR>
else
  nnoremap <Leader>fa :find *
endif

cnoremap %% <C-R>=expand('%:h').'/'<cr>
nmap - :edit %%<CR>
nmap <Leader>- :edit %%

" vim-fugitive
if PluginLoaded('vim-fugitive')
  nnoremap <Leader>gb :Gblame<CR>
  nnoremap <Leader>gs :Gstatus<CR>
  nnoremap <Leader>gd :Gdiff<CR>
  nnoremap <Leader>gc :Gcommit<CR>
  nnoremap <Leader>gp :Gpush<CR>
  nnoremap <Leader>gl :Glog<CR>:copen<CR>
  nnoremap <Leader>gv :GV!<CR>
  vnoremap <Leader>gv :GV!<CR>
endif

" yank and paste from clipboard
xnoremap <Leader>y "*y
nnoremap <Leader>p "0p
nnoremap <Leader>P "0P

nnoremap <Leader>cp :let @+ = expand("%")<CR>

" Switch to last active buffer
noremap <Leader><Leader> :buffer #<CR>
nnoremap <Leader><Tab> :buffer #<CR>

if PluginLoaded('fzf.vim')
  " For fuzzy finding thru buffers
  nnoremap <Leader>b :FzfBuffers<CR>
else
  " Quick jump to buffers
  nnoremap <Leader>b :ls<cr>:b<space>
end

" More logical
map Y y$

" Select last edited/pasted text
nnoremap gV `[v`]

" Select current line char-wise
nnoremap vv ^vg_

" Buhbye accidental help
nnoremap <F1> <Esc>
xnoremap <F1> <Esc>
inoremap <F1> <Esc>

" Change, highlight, repeat
nnoremap <Leader>cw *``cgn

" replace all occurences of current word
nnoremap <Leader>ra :%s/\<<C-r>=expand('<cword>')<CR>\>/

" replace occurrences inside this block
nnoremap <Leader>ri :'{,'}s/\<<C-r>=expand('<cword>')<CR>\>/

" Because un-selecting is dumb
xnoremap > >gv
xnoremap < <gv

" Make n always forward, N always backwards
nnoremap <expr> n 'Nn'[v:searchforward]
nnoremap <expr> N 'nN'[v:searchforward]

" Death to arrow keys
cnoremap <c-n>  <down>
cnoremap <c-p>  <up>

" Move lines up/down
nnoremap [e  :<c-u>execute 'move -1-'. v:count1<cr>
nnoremap ]e  :<c-u>execute 'move +'. v:count1<cr>

" Add empty lines
nnoremap [<space>  :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[
nnoremap ]<space>  :<c-u>put =repeat(nr2char(10), v:count1)<cr>

" Handle matching pairs correctly
inoremap {<CR> {<CR>}<C-o>O
inoremap (<CR> (<CR>)<C-o>O
inoremap [<CR> [<CR>]<C-o>O

" COMMANDS

" Debug colours
command! SS echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')

" Because shift is hard to let go of okay
command! Wq wq
command! WQ wq
command! W w
command! Q q

command! Reload :so ~/dotfiles/vimfiles/vimrc
command! EC edit ~/dotfiles/vimfiles/vimrc
command! EV vsplit ~/dotfiles/vimfiles/vimrc
command! ES split ~/dotfiles/vimfiles/vimrc

" AUTOCOMMANDS

augroup FileTypeSettings
  autocmd!
  autocmd FileType html setlocal ts=2 sw=2 expandtab
  autocmd FileType ruby setlocal ts=2 sw=2 expandtab
  autocmd FileType vim setlocal ts=2 sw=2 expandtab keywordprg=:help
  autocmd FileType haskell setlocal ts=2 sw=2 expandtab
  autocmd FileType python setlocal ts=4 sw=4 expandtab
  autocmd FileType javascript setlocal ts=2 sw=2 expandtab
  autocmd FileType coffee setlocal ts=2 sw=2 expandtab
  autocmd FileType sh,zsh setlocal ts=2 sw=2 expandtab
  autocmd FileType go setlocal ts=2 sw=2 noexpandtab
  autocmd FileType rust setlocal ts=4 sw=4 expandtab makeprg=cargo
  autocmd FileType yaml setlocal ts=2 sw=2 expandtab

  " Who uses modula2???
  autocmd BufNewFile,BufRead *.md set filetype=markdown
  autocmd BufNewFile,BufRead *.css set filetype=scss
  autocmd BufNewFile,BufRead *.q set filetype=sql " Hive
  autocmd BufNewFile,BufRead Fastfile,Appfile,Scanfile,Deliverfile set filetype=ruby


  " spell check git commit messages and markdown files
  autocmd FileType markdown setlocal spell
  autocmd FileType gitcommit setlocal spell
  autocmd FileType text setlocal spell

  autocmd FileType git nnoremap <buffer> q :Sayonara<CR>

  autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
  autocmd FileType ruby,eruby let g:rubycomplete_rails = 1
  autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1
  autocmd FileType ruby,eruby let g:rubycomplete_include_object = 1
  autocmd FileType ruby,eruby let g:rubycomplete_include_objectspace = 1

  autocmd FileType ocaml setlocal indentexpr=ocpindent#OcpIndentLine()
  autocmd FileType ocaml nnoremap <buffer> <Leader>mt :MerlinTypeOf<CR>
  autocmd FileType ocaml nnoremap <buffer> <Leader>mg :MerlinGrowEnclosing<CR>
  autocmd FileType ocaml nnoremap <buffer> <Leader>ms :MerlinShrinkEnclosing<CR>
  autocmd FileType ocaml nnoremap <buffer> <Leader>mc :MerlinClearEnclosing<CR>
  autocmd FileType ocaml setlocal indentexpr=ocpindent#OcpIndentLine()
  autocmd FileType ocaml setlocal indentexpr=ocpindent#OcpIndentLine()
augroup END

augroup Trim
  autocmd!
  autocmd BufWritePre * call TrimWhitespace()
augroup END

augroup RubyMarks
  autocmd!
  autocmd BufLeave app/models/*.rb normal! mM
  autocmd BufLeave app/controllers/*.rb normal! mC
  autocmd BufLeave app/views/*.rb normal! mV
  autocmd BufLeave specs/*spec.rb normal! mS
augroup END

function! Help()
  if &buftype == 'help'
    wincmd T
    nnoremap <buffer> q :q<CR>
  endif
endfunction

augroup VimHelp
  autocmd!
  autocmd BufEnter *.txt call Help()
augroup END

if PluginLoaded('vim-dirvish')
  augroup Dirvish
    autocmd!
    autocmd FileType dirvish nnoremap <buffer> v
        \ :vsp <C-R>=fnameescape(getline('.'))<CR><CR>
    autocmd FileType dirvish nnoremap <buffer> s
        \ :sp <C-R>=fnameescape(getline('.'))<CR><CR>
    autocmd FileType dirvish nnoremap <buffer> <C-R> :<C-U>Dirvish %<CR>
    autocmd FileType dirvish nnoremap <buffer> gh
        \ :set ma<bar>g@\v/\.[^\/]+/?$@d<cr>:set noma<cr>
  augroup END
endif

" EXTRA VIMFILES

call Load(Vimfiles("colors.vim"))
call Load(Vimfiles("statusline.vim"))

if has('nvim')
  call Load(Vimfiles("neo.vim"))
end

if has('mac')
  call Load(Vimfiles("mac.vim"))
endif

call Load("~/.vimrc.local")

function! CCR()
    let cmdline = getcmdline()
    command! -bar Z silent set more|delcommand Z
    if cmdline =~ '\v\C^(ls|files|buffers)'
        " like :ls but prompts for a buffer command
        return "\<CR>:b"
    elseif cmdline =~ '\v\C/(#|nu|num|numb|numbe|number)$'
        " like :g//# but prompts for a command
        return "\<CR>:"
    elseif cmdline =~ '\v\C^(dli|il)'
        " like :dlist or :ilist but prompts for a count for :djump or :ijump
        return "\<CR>:" . cmdline[0] . "j  " . split(cmdline, " ")[1] . "\<S-Left>\<Left>"
    elseif cmdline =~ '\v\C^(cli|lli)'
        " like :clist or :llist but prompts for an error/location number
        return "\<CR>:sil " . repeat(cmdline[0], 2) . "\<Space>"
    elseif cmdline =~ '\C^old'
        " like :oldfiles but prompts for an old file to edit
        set nomore
        return "\<CR>:Z|e #<"
    elseif cmdline =~ '\C^changes'
        " like :changes but prompts for a change to jump to
        set nomore
        return "\<CR>:Z|norm! g;\<S-Left>"
    elseif cmdline =~ '\C^ju'
        " like :jumps but prompts for a position to jump to
        set nomore
        return "\<CR>:Z|norm! \<C-o>\<S-Left>"
    elseif cmdline =~ '\C^marks'
        " like :marks but prompts for a mark to jump to
        return "\<CR>:norm! `"
    elseif cmdline =~ '\C^undol'
        " like :undolist but prompts for a change to undo
        return "\<CR>:u "
    else
        return "\<CR>"
    endif
endfunction

cnoremap <expr> <CR> CCR()

